<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Yangxue1988-yangxue1988.github.io : CSS在WebKit和Blink下的区域绘制" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Yangxue1988-yangxue1988.github.io</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Yangxue1988/Yangxue1988-Yangxue1988.github.io">View on GitHub</a>

          <h1 id="project_title">Yangxue1988-yangxue1988.github.io</h1>
          <h2 id="project_tagline">CSS在WebKit和Blink下的区域绘制</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/Yangxue1988/Yangxue1988-Yangxue1988.github.io/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/Yangxue1988/Yangxue1988-Yangxue1988.github.io/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><a href="http://blogs.adobe.com/webplatform/2013/10/28/css-regions-painting-in-webkit-and-blink/">http://blogs.adobe.com/webplatform/2013/10/28/css-regions-painting-in-webkit-and-blink/</a>
由安德烈•布库尔发表于2013年10月28日 
CSS 2.1规范定义了一个盒模型用来显示文档里面的内容。WebKit和Blink引擎遵守本规范并且予以实现，那么，假设当显示一个文档布局时，布局的元素作为一个单独的盒子，在混合添加碎片时，你可能最终为一个单一的元素使用了多个盒子。这意味着，引擎必须做一些技巧来正确渲染盒子片段。大多数碎片实现方面都覆盖在我以前的博客“WebKit的CSS中的碎片”里。在这篇文章中，我想专注于CSS的区域绘制是如何实现的。
 图1
让我们考虑一个文档，定义一个指定的流（一个RenderFlowThread对象）包含一个流过3个指定宽高的区域的大段落。第一步中，布局中只有body元素的内容，忽略指定流中的元素。此步中，将计算页面中这个区域（RenderRegion对象）的大小和位置。在第二步中，引擎勾画出流线程的内容。正如你可以看到的，各地区有不同的宽度，这将影响线框的大小。在图1中，可以看到布局后的流线程草图。段落的每一个片段是不同的颜色，以反映该区域将被定位的地方。规范地说，流线的宽度是最宽的区域的宽度（在我们的案例中，是区域三）。通过利用存储在RenderBoxRegionInfo类型对象的信息，每个区域内容块的宽度决定了线框的宽度。他们包含需要调整的每一个区域块的宽度值。剩余的上一个区域的最后一行，到下一个区域的第一行之间的空白是分页支柱（在图1中灰色箭头表示的），内容的偏移是为了模拟自然断点。因为流线程的高度是所有区域高度的总和，如果内容太多，包括所有区域的内容将会溢出流线程（见流线程的底部）。
 图2
内容片断的真证被渲染是在绘图的时候。当一个区域将要被绘制时，它会调整制图背景的位置，以及抵消流线程层，以便绘制能在区域内容盒内部的正确位置。流线程的整个内容利用RenderBoxRegionInfo对象调整它的宽度，所以一切看起来都像在区域内部的一样（例如边框和阴影等）。部分流线程并不和预期的一样（例如属于其它区域的部分），它们被裁剪如图2的灰色部分那样。在最后一个区域，你可以看到底部溢出的区域没有被裁剪。这是因为裁剪是利用了RenderFlowThread的视觉溢出，包括所有的内容都没有自绘制的层。流线程的内容（包括溢出）被区域内容盒子分开，区域绘制仅仅是流的一部分。在绘制过程的最后，文档流看起来像如下图3，每个区域包括流的一部分，在最后一个区域的溢出是可见的。</p>

<p>图3
我们目前正在研究的最重要的改进是把流线程的绘制委托给区域层，而不是目前实现的区域渲染。这能使我们结合流线程绘制和树层结构，并且修复一些保留在实现层面的主要的bug（例如：对相对定位溢出区域的错误裁剪）。</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Yangxue1988-yangxue1988.github.io maintained by <a href="https://github.com/Yangxue1988">Yangxue1988</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
