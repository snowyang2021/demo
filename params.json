{"name":"Yangxue1988-yangxue1988.github.io","tagline":"CSS在WebKit和Blink下的区域绘制","body":"http://blogs.adobe.com/webplatform/2013/10/28/css-regions-painting-in-webkit-and-blink/\r\n由安德烈•布库尔发表于2013年10月28日 \r\nCSS 2.1规范定义了一个盒模型用来显示文档里面的内容。WebKit和Blink引擎遵守本规范并且予以实现，那么，假设当显示一个文档布局时，布局的元素作为一个单独的盒子，在混合添加碎片时，你可能最终为一个单一的元素使用了多个盒子。这意味着，引擎必须做一些技巧来正确渲染盒子片段。大多数碎片实现方面都覆盖在我以前的博客“WebKit的CSS中的碎片”里。在这篇文章中，我想专注于CSS的区域绘制是如何实现的。\r\n 图1\r\n让我们考虑一个文档，定义一个指定的流（一个RenderFlowThread对象）包含一个流过3个指定宽高的区域的大段落。第一步中，布局中只有body元素的内容，忽略指定流中的元素。此步中，将计算页面中这个区域（RenderRegion对象）的大小和位置。在第二步中，引擎勾画出流线程的内容。正如你可以看到的，各地区有不同的宽度，这将影响线框的大小。在图1中，可以看到布局后的流线程草图。段落的每一个片段是不同的颜色，以反映该区域将被定位的地方。规范地说，流线的宽度是最宽的区域的宽度（在我们的案例中，是区域三）。通过利用存储在RenderBoxRegionInfo类型对象的信息，每个区域内容块的宽度决定了线框的宽度。他们包含需要调整的每一个区域块的宽度值。剩余的上一个区域的最后一行，到下一个区域的第一行之间的空白是分页支柱（在图1中灰色箭头表示的），内容的偏移是为了模拟自然断点。因为流线程的高度是所有区域高度的总和，如果内容太多，包括所有区域的内容将会溢出流线程（见流线程的底部）。\r\n 图2\r\n内容片断的真证被渲染是在绘图的时候。当一个区域将要被绘制时，它会调整制图背景的位置，以及抵消流线程层，以便绘制能在区域内容盒内部的正确位置。流线程的整个内容利用RenderBoxRegionInfo对象调整它的宽度，所以一切看起来都像在区域内部的一样（例如边框和阴影等）。部分流线程并不和预期的一样（例如属于其它区域的部分），它们被裁剪如图2的灰色部分那样。在最后一个区域，你可以看到底部溢出的区域没有被裁剪。这是因为裁剪是利用了RenderFlowThread的视觉溢出，包括所有的内容都没有自绘制的层。流线程的内容（包括溢出）被区域内容盒子分开，区域绘制仅仅是流的一部分。在绘制过程的最后，文档流看起来像如下图3，每个区域包括流的一部分，在最后一个区域的溢出是可见的。\r\n \r\n图3\r\n我们目前正在研究的最重要的改进是把流线程的绘制委托给区域层，而不是目前实现的区域渲染。这能使我们结合流线程绘制和树层结构，并且修复一些保留在实现层面的主要的bug（例如：对相对定位溢出区域的错误裁剪）。\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}